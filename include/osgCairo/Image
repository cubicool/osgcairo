// -*-c++-*- osgCairo - Copyright (C) 2010 Jeremy Moles

#ifndef OSGCAIRO_IMAGE
#define OSGCAIRO_IMAGE

#include <osg/Image>
#include <osgCairo/Surface>

namespace osgCairo {

//! The Image class is our bread and butter object; this is where most of the magic
//! takes place. It derives from both Surface (providing the cairo context) and
//! osg::Image, which is where the actual data is stored (so that we can take
//! advantage of OSG's image management API).
class OSGCAIRO_EXPORT Image: public Surface, public osg::Image {
protected:
	bool        _allocated;
	CairoFormat _format;

	//! If you want to derive from Surface, your subclass needs to provide this
	//! virtual routine. In the case of Image, we use the cairo C API to create
	//! an image surface internally. If you wanted to create a PDF or SVG surface
	//! in your custom class, you would use the appropriate functions in your
	//! derivative.
	virtual CairoSurface* _createSurfaceImplementation();
	
public:
	META_Object(osgCairo, Image);

	//! Default constructor; requires that you call allocateSurface manually later.
	//! This is useful when you don't know the dimensions and whatnot when the Image
	//! is created.
	Image(CairoFormat format = CAIRO_FORMAT_ARGB32);

	//! Constructor that makes a single call to allocateSurface for you. These args
	//! match the arguments to allocateSurface, so please see that documentation for
	//! further information.
	Image(
		unsigned int         width,
		unsigned int         height,
		CairoFormat          format = CAIRO_FORMAT_ARGB32,
		const unsigned char* data   = 0
	);
	
	Image(const Image& image, const osg::CopyOp& co);

	//! The first two arguments are the power-of-two image dimensions; your GPU
	//! must support this size. The final argument is whether or not you want to use
	//! a buffer of data initially. By default, the entire surface area is set to all 0's,
	//! which means different things for different format types; usually black or completely
	//! transparent black. If you do specify a buffer of image data, you'll need to make
	//! sure it's formatted properly against the CairoFormat object you used in the constructor.
	virtual bool allocateSurface(
		unsigned int         width,
		unsigned int         height,
		const unsigned char* datat = 0
	);

	//! Returns whether or not the Image is valid internally.
	virtual bool valid() const {
		return osg::Image::valid() && _allocated;
	}

	// Returns the CairoFormat used internally.
	CairoFormat getFormat() const {
		return _format;
	}

	//! Readjusts the context's matrix so that the origin is in the bottom-left, like OpenGL.
	//! By default the origin is in the upper-left.
	void setOriginBottomLeft();

	//! Applies a gaussian blur to the image; this operation is currently PERMANENT and affects
	//! the entire image. USE WITH CAUTION.
	void gaussianBlur(unsigned int kernel = 10);

	//! A helper utility function which will return the image size in memory in bytes.
	unsigned int getImageSizeInBytes() const;
};

//! This is a special global function that will create a data buffer to be used during an
//! Images's allocateSurface using an exisiting osg::Image and a desired CairoFormat format.
//! This doesn't work for all osg::Image formats, so be sure you check the return value
//! is non-zero.
OSGCAIRO_EXPORT unsigned char* createNewImageDataAsCairoFormat(
	osg::Image* image,
	CairoFormat format
);

}

#endif
