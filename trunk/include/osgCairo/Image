// -*-c++-*- osgCairo - Copyright (C) 2011 osgCairo Development Team
// $Id$

//! \file
//! \brief Defines osgCairo::Image, the main object in osgCairo.

#ifndef OSGCAIRO_IMAGE
#define OSGCAIRO_IMAGE

#include <cairo.h>
#include <osg/Image>
#include <osgCairo/Export>

namespace osgCairo {

//! The Image class is our bread and butter object; this is where most of the magic
//! takes place. It derives from both Surface (providing the cairo context) and
//! osg::Image, which is where the actual data is stored (so that we can take
//! advantage of OSG's image management API).
class OSGCAIRO_EXPORT Image: public osg::Image {
public:
	META_Object(osgCairo, Image);

	//! Default constructor; requires that you call allocateSurface manually later.
	//! This is useful when you don't know the dimensions of the Image beforehand.
	Image();

	//! Constructor that makes a single call to allocateSurface for you. These args
	//! match the arguments to allocateSurface, so please see that documentation for
	//! further information.
	//! @param width foo
	//! @param height bar
	//! @see allocateSurface
	Image(
		unsigned int               width,
		unsigned int               height,
		cairo_format_t             format = CAIRO_FORMAT_ARGB32,
		unsigned char const *const data   = 0
	);
	
	Image(const Image& image, const osg::CopyOp& co = osg::CopyOp::SHALLOW_COPY);

	virtual ~Image();

	//! The first two arguments are the power-of-two image dimensions; your GPU
	//! must support this size. The final argument is whether or not you want to use
	//! a buffer of data initially. By default, the entire surface area is set to all 0's,
	//! which means different things for different format types; usually black or completely
	//! transparent black. If you do specify a buffer of image data, you'll need to make
	//! sure it's formatted properly against the CairoFormat object you used in the constructor.
	virtual bool allocateSurface(
		unsigned int               width,
		unsigned int               height,
		cairo_format_t             format = CAIRO_FORMAT_ARGB32,
		unsigned char const *const data   = 0
	);

	//! Returns a cairo_t* to be used with the Cairo C API. This must be destroyed with the
	//! cairo_destroy() function.
	cairo_t* createContext() const;

	//! Returns whether or not the Image is valid internally.
	virtual bool valid() const;

	//! Returns the internal Cairo surface; in our case, an "image" surface.
	cairo_surface_t* getSurface() const;

	//! Returns the cairo_format_t enum; usually ARGB32 or A8.
	cairo_format_t getSurfaceFormat() const;

	//! Returns the surface width.
	int getSurfaceWidth() const;

	//! Returns hte surface height.
	int getSurfaceHeight() const;

	//! Returns the "stride" of a row of pixels; this is calculated by mulitplying the number
	//! of bytes-per-unit times the number of columns.
	int getSurfaceStride() const;

	//! Returns a read-write pointer to the internal data. REMEMBER: Cairo stores data with
	//! pre-multiplied alpha! This is the biggest source of trouble for most new users. :)
	unsigned char* getSurfaceData() const;

	//! A helper utility function which will return the image size in memory in bytes.
	unsigned int getImageSizeInBytes() const;

protected:
	cairo_surface_t* _surface;
};

//! This is a special global function that will create a data buffer to be used during an
//! Images's allocateSurface using an exisiting osg::Image and a desired CairoFormat format.
//! This doesn't work for all osg::Image formats, so be sure you check the return value
//! is non-zero.
OSGCAIRO_EXPORT unsigned char* createNewImageDataAsCairoFormat(
	osg::Image*    image,
	cairo_format_t format
);

}

#endif
